<!--
 * @Author: your name
 * @Date: 2021-01-20 12:52:54
 * @LastEditTime: 2021-01-25 09:39:32
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \markdown\ReadMe.md
-->
# VScdoe + keil
## 1 程序下载与调试

### 1.1模板工程

>位于76页

&emsp;
我们使用的stm32开发板是
STM32F103ZET6，FLASH 容量为512K字节，所以 Programming Algorithm 里面默认会有 512K
型号的 STM32F10x High-density Flash 算法。

>uvprojx 是 **ARM**
>
>uvproj  是 **C51**

**方法二**贴近原来的stm32的**建立模板工程**的方法

### 1.2　文件夹用处

1. CMSIS :　固件库文件
2. FWLIB ：
3. USER  : 
0. DRIVER : 手写的外设驱动文件

&emsp;芯片 STM32F411CCU6。
采用模板2，.vscode 文件夹要在工作区的目录下，添加 `STM32F4xx 256k B flash 256k on-chip Flash` 可以load程序

## 2 stm32的重要概念
### 2.1 内核+外设
&emsp;外设：SRAM,ROM,FLASH,USART,GPIO等

&emsp;外设 →**总线**→ 内核    

&emsp;11条总线 主控 S0~S5,有被控总线5条 M0~M4

&emsp;其实不管我们用库开发还是寄存器开发我们本质上就是在控制寄存器上的每个位的通断，并且这些寄存器都有其特定的功能。换句话说每个外设（如GPIO、USART、I2C、SPI…）都对应有寄存器来对他控制。如果把单片机比作一架钢琴的话，那么所有的外设的寄存器就是钢琴上的琴键，每个外设寄存器都对应着某种功能就像是每个琴键都对应着某个美妙音符。钢琴家用手指控制琴键发出悦耳声音就像我们用程序控制外设寄存器让外设勤劳的工作。钢琴家用手指控制着琴键弹奏出一曲美妙的音乐，而我们用程序控制着外设实现了四轴的稳定飞行。这样一想我们是不是也应该是艺术家了嘿嘿。嵌入驱动….工程师、程序、寄存器、单片机的关系如图所示：
<img src = picture\关系图.PNG>

### 2.2 存储器
&emsp;其实STM32内部的程序存储器（FLASH）、数据寄存储器（RAM）、寄存器和I0端口都排列在同一个顺序的4GB的地址空间内，**我们编程时也就是依据此地址来找到相应寄存器操作**。存储器、寄存器本身不具有地址信息，他的地址是由芯片厂商或用户分配，给存储器和寄存器分配地址的过程就称为存储器映射。

&emsp;4GB的内存，ARM公司跟分成个block，每个512M，本芯片只用到3个，block0~2。
1. block0 ：flash   可以理解为程序存储器
1. block1 ：数据存储器 ：SRAM ：可以理解为内存条，局部变量、堆栈等
0. block2 : 设计外部寄存器  
根据不同的总线速度分为APB（低）和AHB（高），又有APB1,2和AHB1,2，如图
<img src = picture\外设地址映射.PNG>


**查表**   
&emsp;看上图左表第一列就表示寄存器的“偏移量”我们通常叫它“寄存器偏移地址”，我们就是根据这个偏移地址得到寄存器的地址的。**这个“寄存器偏移地址”
的偏移是指相对于“外设基地址”的偏移量**。其实外设基地址也就是外设地址范围内的最低地址。例如TIM2的地址范围是0×40000000-0x400003FFF，那么TIM2的基地址为0x40000000。类似于外设基地址的定义总线基地址也是总线地址范围内的最低地址。***例如***：APB1总线的基地址就是0x40000000，我们发现TIM2外设的基地址与APB1的基地址相同，说明0x40000000既是APB1的基地址也是TIM2的基地址。有了基地址和偏移量的概念我们也就可以通过偏移量和基地址找到对应寄存器了。  
外设基地址和寄存器偏移地址在`《RM0383_STM32F411CCU6_Reference manua1》`都能查到，

uint32_t 表示32位无符号数据，转换之后为地址   
stm32f4xx.h将所有的外设寄存器封装了一遍，便于认识别名


## 3 stmF4xx 对 寄存器的封装
### 3.1关键字 volatile   
&emsp;以中断处理程序修改变量解释可能不太合适，以GPIO为例最合适。首先什么是变量？变量就是一块编了地址的内存区域。GPIO的数据寄存器有一个地址，大小一般为32bit，所以这个数据寄存器可以认为就是一个变量，我们可以读写它。如果GPIO设置为输入，修改GPIO数据寄存器这个变量的就是这个GPIO的引脚，不管你如何分析你的程序，你不可能知道这个GPIO数据寄存器里面值是多少，你得读它。你此刻读到数据和下一刻读到的完全可能是不一样的。简单的说就是你要的数据不同步。使用volatile修饰后，会强制你每次引用GPIO寄存器对应的变量时都会去它的寄存器里面读。

### 3.2 结构体
&emsp;这段代码用typedef关键字声明了名为GPI0_TypeDef的结构体类型，结构体内有8个成员变量，变量名正好对应寄存器的名字。**C语言的语法规定，结构体内变量的存储空间是连续的**，其中32位的变量占用4个字节，16位的变量占用2个字节，具体见图2-8：

## 参考资料
在上面我们也已经给大家打开看了许多ST官方的资料文档，大家在学习STM32F4的时候有几个比较重要的官方手册大家需要时可以着重阅读：   
`《STM32F4中文参考手册》`       
`《RM0383_STM32F411CCU6_Reference manual》`
`《DS10314_STM32F411CCU6_Datasheet》`   
`《Cortex M3与M4权威指南》英文版`  
其中最常用的就是《RM0383_STM32F411CCU6_Reference manual》和《STM32F4中文参考手册》，其实学习F4用《STM32F4中文参考手册》就够了，但是我们DragonFly四轴用的是STMF411CCU6，这款芯片出的比较晚然后外设方面有一点改动所以他单独有一个参考手册《RM0383_STM32F411CCU6_Reference manual》
并且还是英文的，**所以为了大家方便阅读，我们可以以《STM32F4中文参考手册》
为主**，然后以《RM0383_STM32F411CCU6_Reference manua1》为辅进行阅读其实一般的外设连个手册几乎没有区别。           

《STM32F4中文参考手册》参考手册详细介绍了STM32F4片上的每个外设，工作原理、模式配置、寄存器配置等，这对于我们理解外设工作和配置外设工作是一个绝佳的指导手，如果有精力建议通读一遍。   
《DS10314_STM32F411CCU6_Datasheet》这是STMF411CCU6的数据手册，里面介绍了STMF411CCU6的外设多少、芯片特性、原理图封装、电气特性、引脚分配等，我们一般用它来看引脚分配。  
《Cortex M3与M4权威指南》这个文档，详细介绍了Cortex M3和Cortex M4内核STM32F4开发指南（库函数版）的体系架构，并配有简单实例，对于想深入了解Cortex M4内核的朋友，此文档是非常好的参考资料，不过该文档目前只有英文版的，对于英文很犯怵的朋友，可能有点不适应。不过由于CM3和CM4很多地方都是通用的，所以有的时候，可以参考《Cortex M3权威指南（中文）》这个文档。